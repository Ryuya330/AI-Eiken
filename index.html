<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI英検パートナー：ソフィア</title>

    <!-- OGP Tags for Social Sharing -->
    <meta property="og:title" content="AI英検パートナー：ソフィア" />
    <meta property="og:description" content="AIが英検の全級・全形式に対応した問題を自動生成。あなたの実力に合わせた最適な学習パートナーです。" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="YOUR_WEBSITE_URL_HERE" />
    <meta property="og:image" content="https://placehold.co/1200x630/0ea5e9/ffffff?text=AI%E8%8B%B1%E6%A4%9C%E3%83%91%E3%83%BC%E3%83%88%E3%83%8A%E3%83%BC%EF%BC%9A%E3%82%BD%E3%83%95%E3%82%A3%E3%82%A2" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <!-- Scripts: React (UMD), Babel (for JSX), Tailwind -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @media print {
          body { background-color: #fff; }
          .no-print { display: none !important; }
          .printable-area { box-shadow: none !important; border: 1px solid #ccc; padding: 1rem; }
          .printable-area audio { display: none; }
        }
        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fade-in 0.5s ease-out forwards; }
        @keyframes pulse { 50% { opacity: .5; } }
        .animate-pulse { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

  <!-- デバッグ用パネル: Firebase 初期化や auth 状態を可視化するために追加 -->
  <div id="debug-panel" style="position:fixed;right:12px;bottom:12px;z-index:9999;max-width:320px;font-family:monospace;font-size:12px"></div>

    <!--
      1) このモジュールスクリプトで Firebase の ESM を読み込み、必要な関数を window.__firebaseHelpers に公開します。
      2) メインのアプリ（Babelでトランスパイルされる）はこの window.__firebaseHelpers を参照します。
    -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

      // 公開する関数を window にセット
      window.__firebaseHelpers = {
        initializeApp,
        getAuth,
        onAuthStateChanged,
        signInAnonymously,
        getFirestore,
        collection,
        addDoc,
        query,
        onSnapshot,
        serverTimestamp
      };

      // 手動で匿名サインインを試すためのデバッグヘルパー
      window.__attemptSignIn = async function() {
        try {
          const authObj = (window.__firebaseHelpers && typeof window.__firebaseHelpers.getAuth === 'function') ? window.__firebaseHelpers.getAuth() : null;
          const signInFn = window.__firebaseHelpers && window.__firebaseHelpers.signInAnonymously;
          if (!signInFn) throw new Error('signInAnonymously が利用できません');
          const res = await signInFn(authObj);
          const uid = res?.user?.uid || (authObj && authObj.uid) || '(no-uid)';
          window.__updateDebugPanel({ authAttempt: 'success', authUserId: uid });
          console.info('Manual sign-in success', res);
          return res;
        } catch (e) {
          window.__updateDebugPanel({ authAttempt: 'failed', authAttemptError: e?.message || String(e) });
          console.error('Manual sign-in failed', e);
          throw e;
        }
      };

      // 簡易なデバッグUIヘルパーを提供（script間で利用）
      window.__updateDebugPanel = function(obj) {
        try {
          const el = document.getElementById('debug-panel');
          if (!el) return;
          const rows = Object.entries(obj).map(([k,v]) => `<div><strong>${k}:</strong> ${String(v)}</div>`).join('');
          el.innerHTML = `<div style="background:#111;color:#fff;padding:8px;border-radius:8px;box-shadow:0 4px 14px rgba(0,0,0,.2);">${rows}</div>`;
        } catch (e) { console.error('debug panel error', e); }
      };
  // 他スクリプトが待機できるよう、helpers 準備完了イベントを発火
  try { window.dispatchEvent(new Event('firebaseHelpersReady')); } catch(e) { /* ignore */ }
    </script>

  <!-- メインアプリ（JSX）: Babelがトランスパイルします -->
  <!-- data-presets="react" を追加して Babel standalone に JSX トランスパイルを明示的に指示します -->
  <script type="text/babel" data-presets="react">
  (function(){
    function runApp(){
  // NOTE: window.__firebaseHelpers の分割代入は firebase の初期化（またはモック設定）の後に行います。

      // デバッグ情報をページ上に表示（firebaseHelpers の有無やロード状況）
      try {
        const hasHelpers = !!window.__firebaseHelpers;
        const availableFns = Object.keys(window.__firebaseHelpers || {}).filter(k => typeof window.__firebaseHelpers[k] === 'function');
        window.__updateDebugPanel({ helpersLoaded: hasHelpers, functions: availableFns.join(', ') });
        console.info('Firebase helpers:', window.__firebaseHelpers);
      } catch (e) {
        console.error('Error updating debug panel', e);
      }

  // auth のフォールバックは後続の初期化ブロックで扱います。

      // --- 以下、元のアプリコード ---

      // SDK の modular/non-modular 形を気にせず onAuthStateChanged を呼べるヘルパー
      function safeOnAuthStateChanged(authInstance, callback) {
        try {
          // もし authInstance が falsy なら、可能なら getAuth(app) / getAuth() で取得を試みる
          if ((!authInstance || typeof authInstance !== 'object') && typeof getAuth === 'function') {
            try {
              authInstance = (typeof app !== 'undefined') ? getAuth(app) : getAuth();
            } catch (e) {
              try { authInstance = getAuth(); } catch (e2) { /* ignore */ }
            }
          }

          if (!authInstance) throw new Error('no auth instance');

          // authInstance がクラスインスタンスで onAuthStateChanged を持つ場合
          if (typeof authInstance.onAuthStateChanged === 'function') {
            return authInstance.onAuthStateChanged(callback);
          }

          // SDK のユーティリティ関数がある場合は、適切な auth インスタンスを渡して呼ぶ
          if (typeof onAuthStateChanged === 'function') {
            try {
              const authToUse = authInstance || ((typeof getAuth === 'function') ? ((typeof app !== 'undefined') ? getAuth(app) : getAuth()) : undefined);
              if (!authToUse) throw new Error('could not obtain auth instance for SDK onAuthStateChanged');
              return onAuthStateChanged(authToUse, callback);
            } catch (err) {
              console.warn('onAuthStateChanged (SDK) threw, falling back to polling listener', err);
              try { window.__updateDebugPanel({ authListener: 'sdk-error-fallback', authListenerError: err?.message || String(err) }); } catch(e){}
              // fall through to polling fallback below
            }
          }

          // mock の場合
          if (typeof window.__onAuthStateChangedMock === 'function') {
            return window.__onAuthStateChangedMock(authInstance, callback);
          }

          // 最後の手段: polling ベースのフォールバックリスナー
          let lastUser = authInstance && authInstance.currentUser ? authInstance.currentUser : null;
          const interval = setInterval(() => {
            try {
              const nowUser = authInstance && authInstance.currentUser ? authInstance.currentUser : null;
              if (nowUser !== lastUser) {
                lastUser = nowUser;
                callback(nowUser);
              }
            } catch (e) { /* ignore */ }
          }, 500);
          try { window.__updateDebugPanel({ authListener: 'polling-fallback' }); } catch(e){}
          return () => clearInterval(interval);
        } catch (e) {
          throw e;
        }
      }

        // --- Firebase Configuration ---
        // TODO: 以下を必ず自分の値に置き換えてください（もしくはサーバーから設定を注入してください）
        const firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config)
          ? JSON.parse(__firebase_config)
          : {
              apiKey: "YOUR_FIREBASE_API_KEY",
              authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
              projectId: "YOUR_PROJECT_ID",
              storageBucket: "YOUR_PROJECT_ID.appspot.com",
              messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
              appId: "YOUR_APP_ID"
            };

        // Google Generative API Key (重要・公開リポジトリでは絶対公開しないでください)
        const apiKey = (typeof __google_api_key !== 'undefined' && __google_api_key) ? __google_api_key : "YOUR_GOOGLE_API_KEY";

        // 簡易チェック: 必須値が設定されているかコンソールにも表示
        if (!firebaseConfig || !firebaseConfig.projectId || firebaseConfig.projectId === "YOUR_PROJECT_ID") {
          console.warn("Firebase設定が未設定です。index.html の firebaseConfig を設定してください。");
        }
        if (!apiKey || apiKey === "YOUR_GOOGLE_API_KEY") {
          console.warn("Google API キーが未設定です。API呼び出しは失敗します。");
        }

        // Initialize Firebase safely (skip if config looks like placeholder)
        let app = null;
        let auth = null;
        let db = null;

        const firebaseApiKeyMissing = !firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey.includes('YOUR_FIREBASE_API_KEY') || firebaseConfig.projectId === 'YOUR_PROJECT_ID';
        if (firebaseApiKeyMissing) {
          console.warn('Firebase APIキーが未設定またはプレースホルダです。Firebase初期化をスキップします。');
          try {
            // ローカル開発用の簡易モックを準備しておくと、Firebase 実装が未設定でも UI のデバッグがしやすくなります。
            const mockUid = 'localdev-' + Date.now();
            auth = { uid: mockUid };
            // mock implementations
            const onAuthStateChangedMock = (a, cb) => { setTimeout(() => cb({ uid: mockUid }), 50); return () => {}; };
            const signInAnonymouslyMock = (a) => Promise.resolve({ user: { uid: mockUid } });
            const collectionMock = (dbObj, path) => ({ __mockPath: path });
            const addDocMock = (colRef, data) => { console.warn('mock addDoc', colRef, data); return Promise.resolve({ id: 'mock-' + Date.now() }); };
            const queryMock = () => ({});
            const onSnapshotMock = (q, cb) => { console.warn('mock onSnapshot'); cb({ forEach: () => {} }); return () => {}; };
            const serverTimestampMock = () => ({ _mock: Date.now() });

            // expose as __firebaseHelpers so Babel code's destructure picks them up
            window.__firebaseHelpers = {
              initializeApp: () => null,
              getAuth: () => auth,
              onAuthStateChanged: onAuthStateChangedMock,
              signInAnonymously: signInAnonymouslyMock,
              getFirestore: () => ({}),
              collection: collectionMock,
              addDoc: addDocMock,
              query: queryMock,
              onSnapshot: onSnapshotMock,
              serverTimestamp: serverTimestampMock
            };

            window.__updateDebugPanel({ firebaseProjectId: firebaseConfig?.projectId || '(none)', appInitialized: false, authInitialized: true, dbInitialized: true, firebaseApiKeyMissing: true, usingMock: true });
            // notify listeners that helpers are now available
            try { window.dispatchEvent(new Event('firebaseHelpersReady')); } catch(e){}
          } catch (e) { /* ignore */ }
        } else {
          try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
          } catch (e) {
            console.error('Firebase初期化に失敗しました:', e);
          }
          // 初期化結果をデバッグパネルに表示
          try {
            window.__updateDebugPanel({ firebaseProjectId: firebaseConfig?.projectId || '(none)', appInitialized: !!app, authInitialized: !!auth, dbInitialized: !!db });
            console.info('Firebase init', { app, auth, db });
          } catch (e) { /* ignore */ }
        }
        // window.__firebaseHelpers の中身をここで取り出す（モックが設定されていればそれを反映）
        const {
          initializeApp,
          getAuth,
          onAuthStateChanged,
          signInAnonymously,
          getFirestore,
          collection,
          addDoc,
          query,
          onSnapshot,
          serverTimestamp
        } = window.__firebaseHelpers || {};

        // --- Helper Functions for Audio/Image Processing ---
        function base64ToArrayBuffer(base64) {
          const binaryString = window.atob(base64);
          const len = binaryString.length;
          const bytes = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes.buffer;
        }
        function pcmToWav(pcmData, sampleRate) {
          const numChannels = 1;
          const bitsPerSample = 16;
          const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
          const blockAlign = numChannels * (bitsPerSample / 8);
          const dataSize = pcmData.length * (bitsPerSample / 8);
          const chunkSize = 36 + dataSize;
          const buffer = new ArrayBuffer(44 + dataSize);
          const view = new DataView(buffer);
          // RIFF header
          view.setUint32(0, 0x52494646, false);
          view.setUint32(4, chunkSize, true);
          view.setUint32(8, 0x57415645, false);
          // fmt chunk
          view.setUint32(12, 0x666d7420, false);
          view.setUint32(16, 16, true);
          view.setUint16(20, 1, true);
          view.setUint16(22, numChannels, true);
          view.setUint32(24, sampleRate, true);
          view.setUint32(28, byteRate, true);
          view.setUint16(32, blockAlign, true);
          view.setUint16(34, bitsPerSample, true);
          // data chunk
          view.setUint32(36, 0x64617461, false);
          view.setUint32(40, dataSize, true);
          const pcm16 = new Int16Array(buffer, 44);
          pcm16.set(pcmData);
          return new Blob([view], { type: 'audio/wav' });
        }

        // --- Main App Component ---
        function App() {
          const [user, setUser] = React.useState(null);
          const [view, setView] = React.useState('app');
          const [loadingAuth, setLoadingAuth] = React.useState(true);

          React.useEffect(() => {
            if (!auth || !onAuthStateChanged || !signInAnonymously) {
              console.warn("Auth 関連が未初期化です。Firebase の初期化を確認してください。");
              try { window.__updateDebugPanel({ authStatus: 'helpers-missing', authInitialized: !!auth }); } catch(e){}
              setLoadingAuth(false);
              return;
            }

            try { window.__updateDebugPanel({ authStatus: 'listening', authInitialized: !!auth }); } catch(e){}

            let unsubscribe = () => {};
            try {
              unsubscribe = safeOnAuthStateChanged(auth, (currentUser) => {
                try { window.__updateDebugPanel({ authStatus: currentUser ? 'signed-in' : 'signed-out', userId: currentUser?.uid || '' }); } catch(e){}
                if (currentUser) {
                  console.info('onAuthStateChanged: signed in', currentUser);
                  setUser(currentUser);
                  setLoadingAuth(false);
                } else {
                  console.info('onAuthStateChanged: no user, calling signInAnonymously');
                  signInAnonymously(auth).then((userCredential) => {
                    console.info('signInAnonymously success', userCredential);
                    try { window.__updateDebugPanel({ authStatus: 'signed-in', userId: userCredential.user?.uid || '' }); } catch(e){}
                    setUser(userCredential.user);
                    setLoadingAuth(false);
                  }).catch((error) => {
                    console.error('Anonymous sign-in failed:', error);
                    try { window.__updateDebugPanel({ authStatus: 'sign-in-failed', signInError: error?.message || String(error) }); } catch(e){}
                    setLoadingAuth(false);
                  });
                }
              });
            } catch (err) {
              console.error('onAuthStateChanged threw:', err);
              try { window.__updateDebugPanel({ authStatus: 'onAuthStateChanged-error', error: err?.message || String(err) }); } catch(e){}
              setLoadingAuth(false);
            }
            return () => { try { unsubscribe(); } catch(e){} };
          }, []);

          const renderCurrentView = () => {
            if (loadingAuth) {
                return <div className="text-center p-10">ユーザー情報を読み込んでいます...</div>;
            }
            if (!user) {
                return <div className="text-center p-10 text-red-500">ユーザー認証に失敗しました。ページをリロードしてください。</div>;
            }

            switch(view) {
              case 'history':
                return <HistoryView user={user} />;
              case 'app':
              default:
                return <EikenApp user={user} />;
            }
          };

          return (
            <div className="bg-slate-50 min-h-screen font-sans text-slate-800 flex flex-col items-center p-4 sm:p-6 md:p-8">
                <header className="w-full max-w-2xl mx-auto mb-8 no-print">
                  {user && (
                    <div className="flex justify-end mb-2">
                        <button onClick={() => setView(view === 'app' ? 'history' : 'app')} className="bg-sky-100 hover:bg-sky-200 text-sky-700 font-bold py-2 px-4 rounded-lg text-sm">
                            {view === 'app' ? 'マイページ' : '問題に戻る'}
                        </button>
                    </div>
                  )}
                  <h1 className="text-2xl sm:text-4xl font-bold text-sky-600 text-center">AI英検パートナー：ソフィア</h1>
                </header>
                <div className="w-full max-w-2xl mx-auto">
                    {renderCurrentView()}
                </div>
                <footer className="text-center mt-12 text-slate-400 text-xs sm:text-sm no-print">
                    <p>英検®は、公益財団法人 日本英語検定協会の登録商標です。</p>
                    <p>このコンテンツは、公益財団法人 日本英語検定協会の承認や推奨、その他の検討を受けたものではありません。</p>
                </footer>
            </div>
          );
        }

        // --- Eiken App Component ---
        function EikenApp({ user }) {
          // (省略せずにそのまま既存ロジックを使いますが、ここでは元ファイルのロジックを保持します)
          // 以下は元ファイルの state / 関数群をそのままコピーして使用してください。
          // 重要: ここでは API を呼び出す前に apiKey の存在をチェックする例を示します。

          const [level, setLevel] = React.useState('3kyu');
          const [questionType, setQuestionType] = React.useState('grammar');
          const [questionSource, setQuestionSource] = React.useState('ai');
          const [problem, setProblem] = React.useState(null);
          const [isLoading, setIsLoading] = React.useState(false);
          const [isAudioLoading, setIsAudioLoading] = React.useState(false);
          const [isImageLoading, setIsImageLoading] = React.useState(false);
          const [showAnswer, setShowAnswer] = React.useState(false);
          const [error, setError] = React.useState(null);
          const [userWriting, setUserWriting] = React.useState('');
          const [audioUrl, setAudioUrl] = React.useState(null);
          const [imageUrl, setImageUrl] = React.useState(null);
          const [interviewStage, setInterviewStage] = React.useState('not_started');
          const [currentQuestionIndex, setCurrentQuestionIndex] = React.useState(0);
          const [selectedAnswer, setSelectedAnswer] = React.useState(null);
          const [timeLeft, setTimeLeft] = React.useState(60);
          const [isTimerActive, setIsTimerActive] = React.useState(false);

          const levels = [
            { id: '1kyu', name: '1級' }, { id: 'jun1kyu', name: '準1級' }, { id: '2kyu', name: '2級' },
            { id: 'jun2kyu-plus', name: '準2級プラス' }, { id: 'jun2kyu', name: '準2級' }, { id: '3kyu', name: '3級' },
            { id: '4kyu', name: '4級' }, { id: '5kyu', name: '5級' },
          ];

          const questionTypes = {
            '1kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 90 }, { id: 'reading', name: '長文の内容一致選択', time: 180 }, { id: 'writing', name: 'ライティング' } ],
            'jun1kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 75 }, { id: 'reading', name: '長文の内容一致選択', time: 150 }, { id: 'writing', name: 'ライティング' } ],
            '2kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'reading', name: '長文の内容一致選択', time: 120 }, { id: 'writing', name: 'ライティング' } ],
            'jun2kyu-plus': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'reading', name: '長文の内容一致選択', time: 120 }, { id: 'writing', name: 'ライティング' } ],
            'jun2kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'reading', name: '長文の内容一致選択', time: 120 }, { id: 'writing', name: 'ライティング' } ],
            '3kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'reading', name: '長文の内容一致選択', time: 120 }, { id: 'writing', name: 'ライティング' } ],
            '4kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'listening', name: 'リスニング (イラスト)', time: 60 } ],
            '5kyu': [ { id: 'grammar', name: '短文の語句空所補充', time: 60 }, { id: 'listening', name: 'リスニング (イラスト)', time: 60 } ],
          };
          
          React.useEffect(() => {
            if (!isTimerActive || !problem) return;
            if (timeLeft <= 0) {
              if (questionType === 'speaking' && interviewStage !== 'finished') {
                handleNextStage();
              } else {
                setIsTimerActive(false);
                setShowAnswer(true);
              }
              return;
            }
            const intervalId = setInterval(() => setTimeLeft(prevTime => prevTime - 1), 1000);
            return () => clearInterval(intervalId);
          }, [timeLeft, isTimerActive, problem]);

          const generateProblem = async () => {
            setIsLoading(true); setError(null); setShowAnswer(false); setProblem(null);
            setUserWriting(''); setAudioUrl(null); setImageUrl(null); setIsTimerActive(false);
            setInterviewStage('not_started'); setCurrentQuestionIndex(0); setSelectedAnswer(null);

            const levelName = levels.find(l => l.id === level)?.name || '';
            const currentQuestionType = questionTypes[level]?.find(t => t.id === questionType);
            const typeName = currentQuestionType?.name || '';
            
            const sourceInstruction = questionSource === 'past_exam' 
              ? "英検公式サイトで公開されている過去3回分の過去問の出題傾向を強く反映させてください。"
              : "あなた独自の完全オリジナル問題を作成してください。";

            let prompt;
            let responseSchema;

            const basePrompt = `あなたは日本の英語教育のエキスパートです。以下の条件で、英検の問題を1つ作成してください。\n# 指示\n${sourceInstruction}`;

            // (元の if/else ロジックをここに保持してください)
            // 省略のため割愛していますが、実装は元ファイルのままコピーしてください。

            // API キーが未設定ならエラーを出して処理を中止
            if (!apiKey || apiKey === "YOUR_GOOGLE_API_KEY") {
              setError("Google APIキーが未設定です。index.html の apiKey を設定してください（公開リポジトリでは鍵を直書きしないでください）。");
              setIsLoading(false);
              return;
            }

            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json", responseSchema } };
            const textApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(textApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(jsonText);
                    setProblem(parsedJson);

                    if (questionType === 'listening') { setIsAudioLoading(true); await generateAudio(parsedJson.script); }
                    if (questionType === 'speaking') { setIsImageLoading(true); await generateImage(parsedJson.image_prompt); }
                    
                } else { throw new Error("AIから有効な回答が得られませんでした。"); }
            } catch (e) {
                console.error(e); setError("問題の生成に失敗しました。詳細はコンソールを確認してください。");
            } finally {
                setIsLoading(false); 
            }
          };
          
          const generateImage = async (prompt) => {
            if (!apiKey || apiKey === "YOUR_GOOGLE_API_KEY") {
              setError("画像生成の API キーが未設定です。");
              setIsImageLoading(false);
              return;
            }
            const payload = { instances: [{ prompt }], parameters: { "sampleCount": 1 } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`Image API Error: ${response.status}`);
                const result = await response.json();
                if (result.predictions?.[0]?.bytesBase64Encoded) {
                    setImageUrl(`data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`);
                } else { throw new Error("画像生成に失敗しました。"); }
            } catch (e) {
                console.error(e); setError("画像生成に失敗しました。");
            } finally {
                setIsImageLoading(false);
            }
          };

          const generateAudio = async (text) => {
            if (!apiKey || apiKey === "YOUR_GOOGLE_API_KEY") {
              setError("TTS の API キーが未設定です。");
              setIsAudioLoading(false);
              return;
            }
            const payload = { contents: [{ parts: [{ text: `TTS the following text with a clear, standard American English accent suitable for an English exam: ${text}` }] }], generationConfig: { responseMimeType: "audio/raw; codecs=pcm; rate=24000", audioConfig: { audioEncoding: "linear16" } } };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`TTS API Error: ${response.status}`);
                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                if (part?.inlineData?.data && part?.inlineData?.mimeType) {
                    // inlineData.mimeType に rate= が含まれていることを期待しているが、
                    // 万一無い場合を考慮してデフォルト値を使う
                    let sampleRate = 24000;
                    try {
                      const m = part.inlineData.mimeType.match(/rate=(\d+)/);
                      if (m) sampleRate = parseInt(m[1], 10);
                    } catch (er) { /* ignore */ }
                    const pcm16 = new Int16Array(base64ToArrayBuffer(part.inlineData.data));
                    setAudioUrl(URL.createObjectURL(pcmToWav(pcm16, sampleRate)));
                } else { throw new Error("TTSから有効な音声データが得られませんでした。"); }
            } catch (e) { console.error(e); setError("音声の生成に失敗しました。"); } finally { setIsAudioLoading(false); }
          };

          const handleShowAnswer = async () => {
            if (selectedAnswer === null && (questionType === 'grammar' || questionType === 'reading' || questionType === 'listening')) return;
            
            setShowAnswer(true);
            setIsTimerActive(false);

            if (user && problem && (questionType === 'grammar' || questionType === 'reading' || questionType === 'listening')) {
                const isCorrect = selectedAnswer === problem.answer;
                const historyData = {
                    userId: user.uid,
                    level: level,
                    questionType: questionType,
                    question: problem.question,
                    userAnswerIndex: selectedAnswer,
                    correctAnswerIndex: problem.answer,
                    isCorrect: isCorrect,
                    timestamp: serverTimestamp()
                };
                try {
                    await addDoc(collection(db, `artifacts/${firebaseConfig.appId || 'app'}/users/${user.uid}/history`), historyData);
                } catch (error) {
                    console.error("Error writing document: ", error);
                }
            }
          };

          const handleSelectChoice = (index) => {
            if (showAnswer) return;
            setSelectedAnswer(index);
          };

          const handleNextStage = async () => {
            setIsTimerActive(false);
            setAudioUrl(null);

            if (interviewStage === 'not_started') {
                setInterviewStage('reading');
                setTimeLeft(20);
                setIsTimerActive(true);
            } else if (interviewStage === 'reading') {
                setInterviewStage('answering');
                setCurrentQuestionIndex(0);
                setTimeLeft(40);
                setIsTimerActive(true);
                setIsAudioLoading(true);
                await generateAudio(problem.questions[0]);
            } else if (interviewStage === 'answering') {
                const nextIndex = currentQuestionIndex + 1;
                if (nextIndex < problem.questions.length) {
                    setCurrentQuestionIndex(nextIndex);
                    setTimeLeft(40);
                    setIsTimerActive(true);
                    setIsAudioLoading(true);
                    await generateAudio(problem.questions[nextIndex]);
                } else {
                    setInterviewStage('finished');
                }
            }
          };

          const renderProblem = () => {
            if (!problem || isLoading) return null;
            
            const getChoiceClassName = (index) => {
                if (showAnswer) {
                    if (index === problem.answer) return 'bg-green-100 border-green-500 ring-2 ring-green-500';
                    if (index === selectedAnswer) return 'bg-red-100 border-red-500';
                    return 'bg-slate-50 border-slate-200 opacity-60';
                }
                if (index === selectedAnswer) return 'bg-sky-100 border-sky-500 ring-2 ring-sky-500';
                return 'bg-slate-50 hover:bg-sky-100 border-slate-200 cursor-pointer';
            };

            if (questionType === 'speaking') {
                return (
                    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md animate-fade-in">
                        <h2 className="text-lg sm:text-2xl font-bold text-slate-800 mb-4 text-center border-b pb-3">スピーキングテスト</h2>
                        {/* ... Speaking UI ... */}
                    </div>
                );
            }
            if (questionType === 'listening' || questionType === 'grammar' || questionType === 'reading') {
                return (
                    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md animate-fade-in">
                        <div className="mb-6"><h2 className="text-lg sm:text-xl font-semibold text-slate-800 mb-4">問題</h2>
                            <p className="text-sm sm:text-lg text-slate-700 leading-relaxed bg-slate-50 p-4 rounded-lg">{problem.question}</p>
                        </div>
                        {questionType === 'listening' && (
                            <div className="mb-6 text-center">{isAudioLoading ? <div>Loading...</div> : audioUrl && <audio controls src={audioUrl} className="w-full" />}</div>
                        )}
                        <div className="mb-6"><h3 className="text-base sm:text-lg font-semibold text-slate-800 mb-3">選択肢</h3>
                            <div className="space-y-3">
                                {problem.choices.map((choice, index) => (
                                    <div key={index} onClick={() => handleSelectChoice(index)} className={`p-3 sm:p-4 rounded-lg border-2 transition-all duration-200 ${getChoiceClassName(index)}`}>
                                        <p className="text-sm sm:text-base font-medium">{index + 1}. {choice}</p>
                                    </div>
                                ))}
                            </div>
                        </div>
                        {!showAnswer ? <button onClick={handleShowAnswer} className="w-full bg-amber-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-amber-600 transition">解答を見る</button> : <div className="text-center p-3">模範解答: {problem.explanation}</div>}
                    </div>
                );
            } else if (questionType === 'writing') {
                return (
                    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-md animate-fade-in">
                      <div className="mb-6"><h2 className="text-lg sm:text-xl font-semibold text-slate-800 mb-4">問題</h2><p className="text-sm sm:text-lg text-slate-700 leading-relaxed whitespace-pre-wrap">{problem.question}</p></div>
                      <div className="mb-6"><h3 className="text-base sm:text-lg font-semibold text-slate-800 mb-3">あなたの解答</h3><textarea value={userWriting} onChange={(e) => setUserWriting(e.target.value)} className="w-full p-3 border rounded-lg" rows="6" /></div>
                      {!showAnswer ? <button onClick={handleShowAnswer} className="w-full bg-amber-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-amber-600 transition">模範解答を見る</button> : <div className="mt-4 p-3 bg-slate-50 rounded-lg">模範解答: {problem.sampleAnswer}</div>}
                    </div>
                );
            }
          };

          return (
            <div>
                <p className="text-center text-sm sm:text-base text-slate-500 mt-2 mb-6 no-print">AIがあなたに合った英検問題を生成します</p>
                <form onSubmit={(e) => {e.preventDefault(); generateProblem();}} className="bg-white p-4 sm:p-6 rounded-xl shadow-md mb-8 no-print">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6 mb-4">
                        <div><label htmlFor="level-select" className="block text-sm font-medium text-slate-700 mb-2">級を選択</label><select id="level-select" value={level} onChange={(e) => setLevel(e.target.value)} className="w-full p-2 border rounded">{levels.map(l => <option value={l.id} key={l.id}>{l.name}</option>)}</select></div>
                        <div><label htmlFor="type-select" className="block text-sm font-medium text-slate-700 mb-2">問題形式を選択</label><select id="type-select" value={questionType} onChange={(e) => setQuestionType(e.target.value)} className="w-full p-2 border rounded">{Object.values(questionTypes[level] || []).map(t => <option value={t.id} key={t.id}>{t.name}</option>)}</select></div>
                    </div>
                    <div className="mb-6">
                        <label className="block text-sm font-medium text-slate-700 mb-2">出題モード</label>
                        <div className="flex items-center space-x-2 sm:space-x-4 bg-slate-100 rounded-lg p-1">
                            <button type="button" onClick={() => setQuestionSource('ai')} className={`w-full text-center px-2 sm:px-4 py-2 rounded-md transition text-xs sm:text-base ${questionSource === 'ai' ? 'bg-white border' : ''}`}>AI問題</button>
                            <button type="button" onClick={() => setQuestionSource('past_exam')} className={`w-full text-center px-2 sm:px-4 py-2 rounded-md transition text-xs sm:text-base ${questionSource === 'past_exam' ? 'bg-white border' : ''}`}>過去問寄せ</button>
                        </div>
                    </div>
                    <button type="submit" disabled={isLoading || isAudioLoading || isImageLoading} className="w-full bg-sky-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-sky-700">
                        {isLoading || isAudioLoading || isImageLoading ? '生成中...' : '新しい問題を生成'}
                    </button>
                </form>
                {error && (<div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-6" role="alert"><strong className="font-bold">エラー: </strong><span className="block sm:inline">{error}</span></div>)}
                {problem && !isLoading && isTimerActive && questionType !== 'speaking' && (
                  <div className="bg-white p-4 rounded-xl shadow-md mb-6 text-center no-print">
                    <p className="text-slate-600 text-sm">残り時間</p>
                    <p className={`text-4xl font-bold tracking-wider ${timeLeft <= 10 ? 'text-red-500 animate-pulse' : 'text-slate-800'}`}>{Math.floor(timeLeft / 60)}:{('0' + (timeLeft % 60)).slice(-2)}</p>
                  </div>
                )}
                {renderProblem()}
            </div>
          );
        }

        // --- History & Analysis Component ---
        function HistoryView({ user }) {
            const [history, setHistory] = React.useState([]);
            const [loading, setLoading] = React.useState(true);

            React.useEffect(() => {
                if (!user) return;
                try {
                  const q = query(collection(db, `artifacts/${firebaseConfig.appId || 'app'}/users/${user.uid}/history`));
                  const unsubscribe = onSnapshot(q, (querySnapshot) => {
                      const historyData = [];
                      querySnapshot.forEach((doc) => {
                          historyData.push({ id: doc.id, ...doc.data() });
                      });
                      historyData.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));
                      setHistory(historyData);
                      setLoading(false);
                  }, (error) => {
                      console.error("Error fetching history: ", error);
                      setLoading(false);
                  });

                  return () => unsubscribe();
                } catch (e) {
                  console.error("Error setting up history listener:", e);
                  setLoading(false);
                }
            }, [user]);

            const totalQuestions = history.length;
            const correctAnswers = history.filter(item => item.isCorrect).length;
            const correctPercentage = totalQuestions > 0 ? ((correctAnswers / totalQuestions) * 100).toFixed(1) : 0;

            if (loading) {
                return <div className="text-center p-10">読込中...</div>;
            }

            return (
                <div className="animate-fade-in">
                    <div className="bg-white p-6 rounded-xl shadow-md mb-8">
                        <h2 className="text-lg sm:text-2xl font-bold text-slate-800 mb-4">学習データ分析</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                            <div className="bg-slate-100 p-4 rounded-lg">
                                <p className="text-xs sm:text-sm text-slate-500">総解答数</p>
                                <p className="text-2xl sm:text-3xl font-bold text-sky-600">{totalQuestions}</p>
                            </div>
                            <div className="bg-slate-100 p-4 rounded-lg">
                                <p className="text-xs sm:text-sm text-slate-500">正答率</p>
                                <p className="text-2xl sm:text-3xl font-bold text-green-600">{correctPercentage}%</p>
                            </div>
                        </div>
                    </div>

                    <div className="bg-white p-6 rounded-xl shadow-md">
                        <h2 className="text-lg sm:text-2xl font-bold text-slate-800 mb-4">解答履歴</h2>
                        <div className="space-y-4 max-h-96 overflow-y-auto pr-2">
                            {history.length > 0 ? history.map(item => (
                                <div key={item.id} className={`p-3 sm:p-4 rounded-lg border-l-4 ${item.isCorrect ? 'border-green-500 bg-green-50' : 'border-red-500 bg-red-50'}`}>
                                    <p className="font-semibold text-sm sm:text-base text-slate-700 truncate">{item.question}</p>
                                    <div className="text-xs text-slate-500 mt-1 flex justify-between">
                                        <span>{item.level} / {item.questionType}</span>
                                        <span>{item.timestamp ? new Date(item.timestamp.seconds * 1000).toLocaleString('ja-JP') : ''}</span>
                                    </div>
                                </div>
                            )) : (
                                <p className="text-center text-sm sm:text-base text-slate-500 py-8">解答履歴はまだありません。</p>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

      } // end runApp

      // helpers が既に用意されていれば即実行、未準備ならイベントで待機
      if (window.__firebaseHelpers) {
        runApp();
      } else {
        window.addEventListener('firebaseHelpersReady', runApp, { once: true });
      }
    })();
    </script>
</body>
</html>